options {
    MULTI=true;
    NODE_PREFIX="";
}

PARSER_BEGIN(FAOPS)

import java.io.FileReader;

import faops.*;

// código Java que invoca o parser
public class FAOPS {
    public static void main(String args[]) throws ParseException {
        // criação do objecto utilizando o constructor com argumento para
        FileReader fr = null;
        try {
            fr = new FileReader("test.faops");

        } catch (Throwable e) {
            System.out.println("File not found");
        }

        FAOPS parser = new FAOPS(fr);
        try {
            SimpleNode start = parser.start();
            start.dump("");
        } catch (Throwable e) {
            e.printStackTrace();
    		System.out.println("Rejected.");
    	}
    }
}
PARSER_END(FAOPS)

// símbolos que não devem ser considerados na análise
SKIP :
{
    " " | "\t" | "\r"
}

// definição dos tokens (símbolos terminais)
TOKEN :
{
    < FA : "FA" >
    | < FANAME : (["A"-"Z"])+ >
    | < QUOTES : ("\"") >
    | < FILENAME : ((["a"-"z"]|["A"-"Z"]|"-"|"_"|["0"-"9"]|".")+ ".dot") >
    | < MULTIPLY : "x" >
    | < CONCATENATE : "." >
    | < INTERSECTION : "int" >
    | < UNION : "+" >
    | < COMPLEMENT : "not(" >
    | < REVERSE : "rev(" >
    | < NEW : "new(" >
    | < DUMP : ".dump(" >
    | < ASSIGN : "=" >
    | < BEGINOPERATION : "(" >
    | < ENDOPERATION : ")" >
    | < ENDLINE : ";" >
    | < LF : "\n" | "\r" | "\r\n" >
}

SimpleNode start() : {} //no bloco definido pelas primeiras chavetas declaram-se variáveis para a função
{
    (((<FA> variable() <ASSIGN> stmt()) | dump()) ((<ENDLINE>)? <LF>))+
    <EOF> {
        System.out.println("File Accepted");
        return jjtThis;
    }
}

void stmt() : {}
{
    ((<NEW> <QUOTES> path() <QUOTES> <ENDOPERATION>)
    | (expr() (op1() expr())?)) {}
}

void variable() : {Token var;} {
    (var = <FANAME>) {
        jjtThis.name = var.image;
    }
}

void path() : {Token path;}
{
    (path = <FILENAME>) {
        jjtThis.name = path.image;
    }
}

void expr() : {}
{
    (op2() stmt() <ENDOPERATION>) |
    (<BEGINOPERATION> stmt() <ENDOPERATION>) |
    (variable())
}

void op1() : {Token op;}
{
    (op = <MULTIPLY>) {
        jjtThis.op = 0;
    }
    | (op = <CONCATENATE>) {
        jjtThis.op = 1;
    }
    | (op = <INTERSECTION>) {
        jjtThis.op = 2;
    }
    | (op = <UNION>) {
        jjtThis.op = 3;
    }
}

void op2() : {Token op;}
{
    (op = <COMPLEMENT>) {
        jjtThis.op = 0;
    }
    | (op = <REVERSE>) {
        jjtThis.op = 1;
    }
}

void dump() : {}
{
    <FANAME> <DUMP> <QUOTES> <FILENAME> <QUOTES> <ENDOPERATION>
}
